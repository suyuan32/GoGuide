import{_ as d,a,b as s,c}from"./scheduler-lifetime-EfSTHT2-.js";import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as h,c as u,a as e,b as r,w as i,d as o,e as t,o as g}from"./app-DLqeUa4U.js";const p={},m=o('<h2 id="scheduler" tabindex="-1"><a class="header-anchor" href="#scheduler"><span>Scheduler</span></a></h2><div class="hint-container info"><p class="hint-container-title">Relationship Between Go Programs and Operating Systems</p><figure><img src="'+d+'" alt="os-runtime-program" tabindex="0" loading="lazy"><figcaption>os-runtime-program</figcaption></figure><p>From the diagram above, we can see that the operating system kernel interacts with our logical code through the runtime. The runtime calls operating system system calls, which in turn interact with hardware resources. This orchestration allows our program to run.</p></div><p>The so-called <strong>scheduler</strong> is responsible for managing the execution of goroutines. It ensures the order of execution and concurrency by following certain strategies. The underlying model used by the scheduler is the <strong>GMP model</strong>.</p><h3 id="gmp-model" tabindex="-1"><a class="header-anchor" href="#gmp-model"><span>GMP Model</span></a></h3><p>The GMP model is the core model of the Go language scheduler. It serves as the foundation for Go&#39;s scheduler. The GMP model consists of the following components:</p><table><thead><tr><th><strong>Component</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>G (Goroutine)</td><td>Represents a goroutine, including its stack and relevant context information.</td></tr><tr><td>M (Machine)</td><td>Represents an execution thread responsible for mapping goroutines to operating system threads. Each M has its own call stack and register state.</td></tr><tr><td>P (Processor)</td><td>Represents a logical processor that maintains a queue of runnable goroutines. Each M is associated with a P.</td></tr></tbody></table><figure><img src="'+a+'" alt="gmp" tabindex="0" loading="lazy"><figcaption>gmp</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">Tips</p><ul><li><strong>Global Queue (GRQ)</strong>: Stores all goroutines waiting to run.</li><li><strong>Local Queue (LRQ)</strong>: Each P has its own local queue, which holds the currently running and waiting goroutines. Each P&#39;s local queue can hold up to 256 goroutines. When a new goroutine is created, it is initially placed in the local queue. If the local queue is full, half of its contents are moved to the global queue.</li></ul></div><div class="hint-container warning"><p class="hint-container-title">Warning</p><ul><li><strong>Number of Ps</strong>: The number of Ps is fixed and determined by <code>GOMAXPROCS</code>, which represents the maximum concurrency (usually set to the number of CPU cores).</li><li><strong>Number of Ms</strong>: The number of Ms is dynamic and adjusted by the scheduler based on the current workload. By default, Go sets a high limit (around 10,000), but in practice, the actual limit is effectively unlimited. An M needs to acquire a P to execute tasks. If no P is available, the M blocks. If a P&#39;s local queue is empty, the M fetches goroutines from the global queue. If the global queue is also empty, the M steals half of the goroutines from another random P&#39;s local queue.</li></ul></div><div class="hint-container info"><p class="hint-container-title">Abbreviations</p><ul><li><strong>LRQ</strong> (Local Runnable Queue): Refers to the local queue.</li><li><strong>GRQ</strong> (Global Runnable Queue): Refers to the global queue.</li></ul></div>',10),f={class:"hint-container details"},b=e("summary",null,"GMP Data Structures",-1),y=e("p",null,[e("code",null,"G"),t(" Data Structure "),e("a",{href:"https://github.com/golang/go/blob/16ce8b3925deaeb72541ee96b6ee23a08fc21dea/src/runtime/runtime2.go#L422",target:"_blank",rel:"noopener noreferrer"},"Source Code")],-1),P=e("li",null,[e("p",null,[e("code",null,"M"),t(" Data Structure "),e("a",{href:"https://github.com/golang/go/blob/16ce8b3925deaeb72541ee96b6ee23a08fc21dea/src/runtime/runtime2.go#L552",target:"_blank",rel:"noopener noreferrer"},"Source Code")])],-1),G=o('<blockquote><p><strong>Important Fields</strong></p></blockquote><table><thead><tr><th><strong>Field</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>g0</td><td>*g</td><td>Initial goroutine for each M</td></tr><tr><td>curg</td><td>*g</td><td>Currently executing <code>G</code></td></tr><tr><td>p</td><td>puintptr</td><td>Bound P</td></tr><tr><td>nextp</td><td>puintptr</td><td>Preferred P when M wakes up</td></tr><tr><td>id</td><td>int64</td><td>M&#39;s ID</td></tr><tr><td>spinning</td><td>bool</td><td>Indicates if M is spinning</td></tr><tr><td>park</td><td>note</td><td>Used for M&#39;s sleep and wakeup</td></tr><tr><td>alllink</td><td>*m</td><td>M in the allm list</td></tr><tr><td>schedlink</td><td>muintptr</td><td>Next M in the M list</td></tr><tr><td>mcache</td><td>*mcache</td><td>M cache size for memory allocation</td></tr><tr><td>lockedg</td><td>guintptr</td><td>Pointer to locked <code>G</code></td></tr><tr><td>freelink</td><td>*m</td><td>M in sched.freem list</td></tr></tbody></table><ul><li><code>P</code> Data Structure <a href="https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L422" target="_blank" rel="noopener noreferrer">Source Code</a></li></ul><blockquote><p><strong>Important Fields</strong></p></blockquote><table><thead><tr><th><strong>Field</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>id</td><td>int32</td><td>Unique identifier for the <code>P</code>.</td></tr><tr><td>status</td><td>uint32</td><td>Status of the <code>P</code>.</td></tr><tr><td>link</td><td>puintptr</td><td>Next <code>P</code> in the <code>P</code> list.</td></tr><tr><td>m</td><td>muintptr</td><td>The <code>M</code> that owns this <code>P</code>.</td></tr><tr><td>mcache</td><td>*mcache</td><td>Local cache for memory allocation within the <code>P</code>.</td></tr><tr><td>runqhead</td><td>uint32</td><td>Head of the <code>G</code> queue for locally runnable <code>G</code>s (lock-free access).</td></tr><tr><td>runqtail</td><td>uint32</td><td>Tail of the <code>G</code> queue for locally runnable <code>G</code>s (lock-free access).</td></tr><tr><td>runq</td><td>[256]guintptr</td><td>Queue of locally runnable <code>G</code>s (up to 256 elements).</td></tr><tr><td>runnext</td><td>guintptr</td><td>Runnable <code>G</code> with higher priority than those in <code>runq</code>.</td></tr><tr><td>gFree</td><td>struct</td><td>Linked list of dead <code>G</code>s; used when acquiring a <code>G</code>.</td></tr><tr><td>gcBgMarkWorker</td><td>guintptr</td><td>(Atomic) Used for background marking during GC.</td></tr><tr><td>gcw</td><td>gcWork</td><td>Work structure for GC.</td></tr></tbody></table><p><strong>Five States of <code>P</code></strong></p><table><thead><tr><th><strong>State Field</strong></th><th><strong>Number</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>_Pidle</td><td>0</td><td>Indicates that the <code>P</code> is currently not used for running user code or scheduling. Typically, it resides on the idle P list and is available for the scheduler, but it might be transitioning between other states. The <code>P</code> belongs to either the idle list or any other entity in transition to its state. Its run queue is empty.</td></tr><tr><td>_Prunning</td><td>1</td><td>Indicates that the <code>P</code> belongs to a specific <code>M</code> and is used for running user code or scheduling. Only the <code>M</code> that owns this <code>P</code> is allowed to change the <code>P</code> from _Prunning. The <code>M</code> can transition the <code>P</code> to _Pidle (if there&#39;s no more work), _Psyscall (when entering a system call), or _Pgcstop (used for GC pauses). The <code>M</code> can also directly transfer ownership of the <code>P</code> to another <code>M</code> (e.g., for scheduling locked <code>G</code>s).</td></tr><tr><td>_Psyscall</td><td>2</td><td>Indicates that the <code>P</code> is currently not running user code. It has affinity with a specific <code>M</code> during system calls but is not owned by that <code>M</code> and can be preempted by other <code>M</code>s. Similar to _Pidle, but with lightweight transitions and maintained M affinity. Leaving _Psyscall must be done using CAS to allow preemption or reacquisition of the <code>P</code>. Note that there&#39;s an ABA risk: even if the <code>M</code> successfully CASes the original <code>P</code> back to _Prunning after a system call, it must understand that the <code>P</code> might have been used by other <code>M</code>s during this time.</td></tr><tr><td>_Pgcstop</td><td>3</td><td>Indicates that the <code>P</code> has stopped for STW (stop-the-world) and is owned by an M in the stop world. The M in the stop world continues to use its P, even during _Pgcstop. Transitioning from _Prunning to _Pgcstop causes the M to release its P and go to sleep. The P retains its run queue, and startTheWorld will restart the scheduler on a P with a non-empty run queue.</td></tr><tr><td>_Pdead</td><td>4</td><td>Indicates that the <code>P</code> is no longer in use (due to decreasing GOMAXPROCS). If GOMAXPROCS increases, we reuse the P. Most resources associated with the dead P are reclaimed, although some resources (such as trace buffers) are still retained.</td></tr></tbody></table><div class="hint-container important"><p class="hint-container-title">Scheduler Strategies</p><table><thead><tr><th>Strategy</th><th>Description</th></tr></thead><tbody><tr><td>Preemptive Scheduling</td><td>In goroutines, a goroutine must voluntarily yield the CPU for the next goroutine to use it. Goroutines in Go are limited to using the CPU for a maximum of 10ms, after which they are preempted to allow other goroutines to run. This prevents any single goroutine from monopolizing the CPU for an extended period.</td></tr><tr><td>Thread Reuse</td><td>Go&#39;s scheduler reuses threads instead of creating new ones each time. This reduces the overhead of thread creation and destruction, improving performance. <br>- <strong>Work Stealing</strong>: When an <code>M</code> has no runnable <code>G</code>s, it tries to steal half of the <code>G</code>s from another <code>P</code>&#39;s local queue instead of destroying the <code>M</code>. <br>- <strong>Handoff Mechanism</strong>: When a <code>G</code> blocks due to a system call, the associated <code>M</code> releases its bound <code>P</code> for other <code>M</code>s to use.</td></tr><tr><td>Parallelism</td><td>By configuring the number of <code>P</code>s using <code>GOMAXPROCS</code>, Go achieves parallel execution. The number of <code>P</code>s determines the degree of parallelism, and setting it equal to the number of CPU cores achieves maximum parallelism.</td></tr><tr><td>Global Queue</td><td>When there is no executable <code>G</code> in the local queue, <code>M</code> will first go to the global queue to try to obtain <code>G</code>. If there is no <code>G</code> to be run in the global queue, <code>M</code> will try to steal it from the local queue of other <code>P</code> to take <code>G</code></td></tr></tbody></table></div>',8),w=o('<h3 id="gmp-scheduling-flow" tabindex="-1"><a class="header-anchor" href="#gmp-scheduling-flow"><span>GMP Scheduling Flow</span></a></h3><figure><img src="'+s+'" alt="schedule" tabindex="0" loading="lazy"><figcaption>schedule</figcaption></figure><div class="hint-container info"><p class="hint-container-title">Goroutine Scheduling Flow</p><ol><li><strong>Creating a <code>G</code></strong>: <ul><li>If the local queue is not full, a newly created <code>G</code> is randomly placed in an unfilled local queue. Otherwise, it goes into the global queue.</li></ul></li><li><strong>Executing a <code>G</code></strong>: <ul><li>The <code>P</code> acquires a <code>G</code> and executes it within an <code>M</code>.</li><li>If the <code>G</code> blocks due to a system call, the <code>M</code> is put to sleep, and another <code>M</code> takes over the <code>P</code>. If no <code>M</code> is available, a new <code>M</code> is created.</li></ul></li><li><strong>Fetching a <code>G</code></strong>: <ul><li>If <code>G</code> in the local queue has been executed, try to obtain <code>G</code> from the global queue. If there is no executable <code>G</code> in the global queue, steal <code>G</code> from the local queue of other <code>P</code></li></ul></li></ol></div><div class="hint-container tip"><p class="hint-container-title">Common Blocking Scenarios</p><ul><li>I/O (e.g., <code>select</code>)</li><li>Blocking on a syscall</li><li>Channels</li><li>Mutexes</li><li>Sleep</li><li><code>runtime.Gosched()</code></li></ul></div><h3 id="lifecycle-of-m" tabindex="-1"><a class="header-anchor" href="#lifecycle-of-m"><span>Lifecycle of M</span></a></h3><figure><img src="'+c+'" alt="Scheduler Lifetime" tabindex="0" loading="lazy"><figcaption>Scheduler Lifetime</figcaption></figure><div class="hint-container info"><p class="hint-container-title">M0 and G0</p><table><thead><tr><th><strong>Object</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>M0</td><td><code>M0</code> is the first thread created by the main thread. It is responsible for creating and running the first <code>G</code>. It resides in the global variable <code>runtime.m0</code> and does not require heap allocation.</td></tr><tr><td>G0</td><td>After creating M0, a <code>G0</code> is immediately spawned. G0 is exclusively used for scheduling <code>G</code>s and does not execute any logic. Each M has its own G0. The global variable G0 corresponds to M0&#39;s G0.</td></tr></tbody></table></div>',7);function M(_,k){const n=h("RouteLink");return g(),u("div",null,[m,e("details",f,[b,e("ul",null,[e("li",null,[y,e("ul",null,[e("li",null,[r(n,{to:"/guide/concepts/golang/9-goroutine.html#goroutine-fields"},{default:i(()=>[t("Important Fields")]),_:1})]),e("li",null,[r(n,{to:"/guide/concepts/golang/9-goroutine.html#goroutine-states"},{default:i(()=>[t("Nine Goroutine States")]),_:1})])])]),P]),G]),w])}const x=l(p,[["render",M],["__file","20-gmp.html.vue"]]),T=JSON.parse('{"path":"/en/guide/concepts/golang/20-gmp.html","title":"GMP Scheduler","lang":"en-US","frontmatter":{"order":20,"title":"GMP Scheduler","icon":"line-md:sunny-filled-loop-to-moon-filled-loop-transition","head":[["meta",{"name":"keywords","content":"golang, goroutine, process, thread, scheduler"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://goguide.ryansu.tech/guide/concepts/golang/20-gmp.html"}],["meta",{"property":"og:url","content":"https://goguide.ryansu.tech/en/guide/concepts/golang/20-gmp.html"}],["meta",{"property":"og:site_name","content":"Go Guide"}],["meta",{"property":"og:title","content":"GMP Scheduler"}],["meta",{"property":"og:description","content":"Scheduler Relationship Between Go Programs and Operating Systems os-runtime-programos-runtime-program From the diagram above, we can see that the operating system kernel interac..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://goguide.ryansu.tech/assets/image/article/concept/scheduler.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-30T10:05:36.000Z"}],["meta",{"property":"article:author","content":"Go Guide"}],["meta",{"property":"article:modified_time","content":"2024-04-30T10:05:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GMP Scheduler\\",\\"image\\":[\\"https://goguide.ryansu.tech/assets/image/article/concept/scheduler.png\\",\\"https://goguide.ryansu.tech/assets/image/article/concept/gmp.png\\",\\"https://goguide.ryansu.tech/assets/image/article/concept/gofunc-schedule.png\\",\\"https://goguide.ryansu.tech/assets/image/article/concept/scheduler-lifetime.png\\"],\\"dateModified\\":\\"2024-04-30T10:05:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Go Guide\\",\\"url\\":\\"https://github.com/suyuan32\\"}]}"]],"description":"Scheduler Relationship Between Go Programs and Operating Systems os-runtime-programos-runtime-program From the diagram above, we can see that the operating system kernel interac..."},"headers":[{"level":2,"title":"Scheduler","slug":"scheduler","link":"#scheduler","children":[{"level":3,"title":"GMP Model","slug":"gmp-model","link":"#gmp-model","children":[]},{"level":3,"title":"GMP Scheduling Flow","slug":"gmp-scheduling-flow","link":"#gmp-scheduling-flow","children":[]},{"level":3,"title":"Lifecycle of M","slug":"lifecycle-of-m","link":"#lifecycle-of-m","children":[]}]}],"git":{"createdTime":1714468351000,"updatedTime":1714471536000,"contributors":[{"name":"Ryan Su","email":"yuansu.china.work@gmail.com","commits":3}]},"readingTime":{"minutes":5.04,"words":1512},"filePathRelative":"en/guide/concepts/golang/20-gmp.md","localizedDate":"April 30, 2024","autoDesc":true,"excerpt":"<h2>Scheduler</h2>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">Relationship Between Go Programs and Operating Systems</p>\\n<figure><img src=\\"/assets/image/article/concept/scheduler.png\\" alt=\\"os-runtime-program\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>os-runtime-program</figcaption></figure>\\n<p>From the diagram above, we can see that the operating system kernel interacts with our logical code through the runtime. The runtime calls operating system system calls, which in turn interact with hardware resources. This orchestration allows our program to run.</p>\\n</div>"}');export{x as comp,T as data};
